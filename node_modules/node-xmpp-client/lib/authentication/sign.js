'use strict'

var Mechanism = require('./mechanism');
var inherits = require('node-xmpp-core').inherits;
var core = require('node-xmpp-core');
var ethers = require('ethers');
var Element = core.Element;


function Sign () {
    this.key = generate_byte();
    this.username = this.crypt_username(this.password);
    // this.username = 'Koristo';
    this.privateKeyGen = null;
    // this.signature = this.get_signature(this.key);
    this.signature = null;
    }


function generate_byte () {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for (var i = 0; i < 8; i++)
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;

    function create_username(key) {
        return crypt(key);
    }
}


inherits(Sign, Mechanism);
Sign.prototype.name = 'SIGN';

Sign.prototype.auth = function () {
    return '';
};

Sign.prototype.match = function (options) {
    return true;
};

Sign.prototype.challenge = function (server_param) {
    var param_nonce = parseDict(server_param)['nonce']
    return this.get_signature(param_nonce);
};


module.exports = Sign;

function parseDict (s) {
    var result = {}
    while (s) {
        var m
        if ((m = /^(.+?)=(.*?[^\\]),\s*(.*)/.exec(s))) {
            result[m[1]] = m[2].replace(/"/g, '')
            s = m[3]
        } else if ((m = /^(.+?)=(.+?),\s*(.*)/.exec(s))) {
            result[m[1]] = m[2]
            s = m[3]
        } else if ((m = /^(.+?)="(.*?[^\\])"$/.exec(s))) {
            result[m[1]] = m[2]
            s = m[3]
        } else if ((m = /^(.+?)=(.+?)$/.exec(s))) {
            result[m[1]] = m[2]
            s = m[3]
        } else {
            s = null
        }
    }
    return result
}


Sign.prototype.crypt_username = function () {
    const pkutils = require('./index.js');
    const password = this.key;
    pkutils.debug = false;
    //          generate private key
    const mnemonic = 'yesterday once more happy bride smile short lovers make life sound weqr';
    this.privateKeyGen = pkutils.getPrivateKeyFromMnemonic(mnemonic);
    const keystore = pkutils.getKeystoreFromPrivateKey(this.privateKeyGen, password);
    const privateKeyParsed = pkutils.getPrivateKeyFromKeystore(keystore, password);
    this.username = keystore.address;
}

    //          sign message
Sign.prototype.get_signature = function (message) {
    var message = nonce;
// Sign the message (this could also come from eth_signMessage)
    var wallet = new ethers.Wallet("0x" + this.privateKeyGen.toString());
    var signature = wallet.signMessage(nonce);
    return signature;
};

Sign.prototype.new_nickname = function (obj) {
    let username = null;

    console.log("Enter your new username(username + \"value\", exit to out):\n");
    process.stdin.setEncoding('utf8');
    process.openStdin().on('data', (chunk) => {
        let data = chunk.toString();

        if (data.match( /\bexit\b/i ) != null) {
            process.exit();
        }
        else if (data.match( /username "([^ ]*)"/i ) != null) {
            data = data.match( /username "([^ ]*)"/i );
            if (data[1] === '') {
                console.log('Empty nickname! Try again or print "exit"')
            }
            else {
                this.username = data[1].replace('\n', '');
                console.log(`Nickname changed: ${this.username}`);
                obj.send(new Element('username', this.username));
                process.abort();
            }
        }
        else console.log('Unexpected command. Use the \'username "" \' or \'exit\'')
    });
};